Circular Linked List Implementation of Circular Queue

Difficulty Level : Easy
Last Updated : 10 Jan, 2023
Read
Discuss
Courses
Practice
Video
Prerequisite â€“ Circular Singly Linked List We have discussed basics and how to implement circular queue using array in set 1. Circular Queue | Set 1 (Introduction and Array Implementation) In this post another method of circular queue implementation is discussed, using Circular Singly Linked List. 

Operations on Circular Queue:

Front:Get the front item from queue.
Rear: Get the last item from queue.
enQueue(value) This function is used to insert an element into the circular queue. In a circular queue, the new element is always inserted at Rear position.
Create a new node dynamically and insert value into it.
Check if front==NULL, if it is true then front = rear = (newly created node)
If it is false then rear=(newly created node) and rear node always contains the address of the front node.
deQueue() This function is used to delete an element from the circular queue. In a queue, the element is always deleted from front position.
Check whether queue is empty or not means front == NULL.
If it is empty then display Queue is empty. If queue is not empty then step 3
Check if (front==rear) if it is true then set front = rear = NULL else move the front forward in queue, update address of front in rear node and return the element.
Operations-on-Circular -Queue 

Recommended: Please try your approach on {IDE} first, before moving on to the solution.
Below is the implementation of the above approach: 

C++
Java
Python3
# Python3 program for insertion and 
# deletion in Circular Queue 
  
# Structure of a Node 
class Node:
    def __init__(self):
        self.data = None
        self.link = None
  
class Queue:
    def __init__(self):
        front = None
        rear = None
  
# Function to create Circular queue 
def enQueue(q, value):
    temp = Node() 
    temp.data = value 
    if (q.front == None): 
        q.front = temp 
    else:
        q.rear.link = temp 
  
    q.rear = temp 
    q.rear.link = q.front
  
# Function to delete element from 
# Circular Queue 
def deQueue(q):
    if (q.front == None):
        print("Queue is empty") 
        return -999999999999
  
    # If this is the last node to be deleted 
    value = None # Value to be dequeued 
    if (q.front == q.rear):
        value = q.front.data
        q.front = None
        q.rear = None
    else: # There are more than one nodes 
        temp = q.front 
        value = temp.data 
        q.front = q.front.link 
        q.rear.link = q.front
  
    return value 
  
# Function displaying the elements 
# of Circular Queue 
def displayQueue(q):
    temp = q.front 
    print("Elements in Circular Queue are: ", 
                                   end = " ") 
    while (temp.link != q.front):
        print(temp.data, end = " ") 
        temp = temp.link
    print(temp.data)
  
# Driver Code
if __name__ == '__main__':
  
    # Create a queue and initialize
    # front and rear 
    q = Queue() 
    q.front = q.rear = None
  
    # Inserting elements in Circular Queue 
    enQueue(q, 14) 
    enQueue(q, 22) 
    enQueue(q, 6) 
  
    # Display elements present in 
    # Circular Queue 
    displayQueue(q) 
  
    # Deleting elements from Circular Queue 
    print("Deleted value = ", deQueue(q)) 
    print("Deleted value = ", deQueue(q)) 
  
    # Remaining elements in Circular Queue 
    displayQueue(q) 
  
    enQueue(q, 9) 
    enQueue(q, 20) 
    displayQueue(q)
  
# This code is contributed by PranchalK
C#
Output
Elements in Circular Queue are: 14 22 6
Deleted value = 14
Deleted value = 22
Elements in Circular Queue are: 6
Elements in Circular Queue are: 6 9 20
Time Complexity: Time complexity of enQueue(), deQueue() operation is O(1) as there is no loop in any of the operation. 

Note: In case of linked list implementation, a queue can be easily implemented without being circular. However, in the case of array implementation, we need a circular queue to save space. 



This article is contributed by Akash Gupta. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.





Like
50
Previous
Introduction and Array Implementation of Circular Queue
Next
Applications, Advantages and Disadvantages of Circular Queue
Related Articles
1.
Should we declare as Queue or Priority Queue while using Priority Queue in Java?
2.
Queue - Linked List Implementation
3.
Introduction and Array Implementation of Circular Queue
4.
Difference between Circular Queue and Priority Queue
5.
Difference Between Linear Queue and Circular Queue
6.
Advantages of circular queue over linear queue
7.
Convert singly linked list into circular linked list
8.
Check if a linked list is Circular Linked List
9.
Introduction and Array Implementation of Queue
10.
Difference between PriorityQueue and Queue Implementation in Java
Article Contributed By :
https://media.geeksforgeeks.org/auth/avatar.png
GeeksforGeeks
Vote for difficulty
Current difficulty : Easy
Easy
Normal
Medium
Hard
Expert
Improved By :
andrew1234
shrikanth13
soumil
PranchalKatiyar
itsthekaybee
hardikkoriintern
anand__yadav
Article Tags :
circular linked list
circular-array
Linked List
Queue
Practice Tags :
circular linked list
Linked List
Queue