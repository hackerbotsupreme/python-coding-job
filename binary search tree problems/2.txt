Introduction to Binary Search Tree – Data Structure and Algorithm Tutorials

Difficulty Level : Medium
Last Updated : 28 Jan, 2023
Read
Discuss
A Binary Search Tree (BST) is a special type of binary tree in which the left child of a node has a value less than the node’s value and the right child has a value greater than the node’s value. This property is called the BST property and it makes it possible to efficiently search, insert, and delete elements in the tree.

The root of a BST is the node that has the largest value in the left subtree and the smallest value in the right subtree. Each left subtree is a BST with nodes that have smaller values than the root and each right subtree is a BST with nodes that have larger values than the root.

Binary Search Tree is a node-based binary tree data structure that has the following properties: 

The left subtree of a node contains only nodes with keys lesser than the node’s key.
The right subtree of a node contains only nodes with keys greater than the node’s key.
This means everything to the left of the root is less than the value of the root and everything to the right of the root is greater than the value of the root. Due to this performing, a binary search is very easy.
The left and right subtree each must also be a binary search tree.  
There must be no duplicate nodes(BST may have duplicate values with different handling approaches)


Handling approach for Duplicate values in the Binary Search tree:

You can not allow the duplicated values at all.
We must follow a consistent process throughout i.e either store duplicate value at the left or store the duplicate value at the right of the root, but be consistent with your approach.
We can keep the counter with the node and if we found the duplicate value, then we can increment the counter
Below are the various operations that can be performed on a BST:

Insert a node into a BST: A new key is always inserted at the leaf. Start searching a key from the root till a leaf node. Once a leaf node is found, the new node is added as a child of the leaf node.
C++
// C++ program to insert a node
// in a BST
#include <bits/stdc++.h>
using namespace std;
 
// Given Node
struct node
{
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp = (struct node*)malloc(
                  sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
     
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key)
    {
        node->left = insert(node->left, key);
    }
    else if (key > node->key)
    {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to do inorder traversal of BST
void inorder(struct node* root)
{
    if (root != NULL)
    {
        inorder(root->left);
        cout << root->key << " ";
        inorder(root->right);
    }
}
 
// Driver Code
int main()
{
     
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Inserting value 50
    root = insert(root, 50);
 
    // Inserting value 30
    insert(root, 30);
 
    // Inserting value 20
    insert(root, 20);
 
    // Inserting value 40
    insert(root, 40);
 
    // Inserting value 70
    insert(root, 70);
 
    // Inserting value 60
    insert(root, 60);
 
    // Inserting value 80
    insert(root, 80);
 
    // Print the BST
    inorder(root);
 
    return 0;
}
 
// This code is contributed by shubhamsingh10
C
Java
Output
20 30 40 50 60 70 80 
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Inorder traversal: In case of binary search trees (BST), Inorder traversal gives nodes in non-decreasing order. We visit the left child first, then the root, and then the right child.
C++
// C++ program to implement
// inorder traversal of BST
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node
{
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
     
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key)
    {
        node->left = insert(node->left, key);
    }
    else if (key > node->key)
    {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to do inorder traversal of BST
void inorder(struct node* root)
{
    if (root != NULL)
    {
        inorder(root->left);
        cout << " " << root->key;
        inorder(root->right);
    }
}
 
// Driver Code
int main()
{
     
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    inorder(root);
 
    return 0;
}
 
// This code is contributed by shivanisinghss2110
C
Java
Output
 20 30 40 50 60 70 80
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Preorder traversal: Preorder traversal first visits the root node and then traverses the left and the right subtree. It is used to create a copy of the tree. Preorder traversal is also used to get prefix expression on of an expression tree.
C++
// C++ program to implement
// preorder traversal
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to do preorder traversal of BST
void preOrder(struct node* root)
{
    if (root != NULL) {
        cout << " " << root->key;
        preOrder(root->left);
        preOrder(root->right);
    }
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    preOrder(root);
 
    return 0;
}
// this code is contributed by shivanisinghss2110
C
Java
Output
 50 30 20 40 70 60 80
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Postorder traversal: Postorder traversal first traverses the left and the right subtree and then visits the root node. It is used to delete the tree. In simple words, visit the root of every subtree last.
C++
// C++ program to print total
// count of nodes in BST
#include <iostream>
using namespace std;
 
// Given Node node
struct node
{
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp = (struct node*)malloc(
                  sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
     
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key)
    {
        node->left = insert(node->left, key);
    }
    else if (key > node->key)
    {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to do postorder traversal of BST
void postOrder(struct node* root)
{
    if (root != NULL)
    {
        postOrder(root->left);
        postOrder(root->right);
        cout << " " << root->key;
    }
}
 
// Driver Code
int main()
{
     
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    postOrder(root);
 
    return 0;
}
 
// This code is contributed by shivanisinghss2110
C
Java
Output
 20 40 30 60 80 70 50
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Level order traversal: Level order traversal of a BST is breadth first traversal for the tree. It visits all nodes at a particular level first before moving to the next level.
C++
// C++ program to implement
// level order traversal
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Returns height of the BST
int height(struct node* node)
{
    if (node == NULL)
        return 0;
    else {
 
        // Compute the depth of each subtree
        int lDepth = height(node->left);
        int rDepth = height(node->right);
 
        // Use the larger one
        if (lDepth > rDepth)
            return (lDepth + 1);
        else
            return (rDepth + 1);
    }
}
 
// Print nodes at a given level
void printGivenLevel(struct node* root,
                     int level)
{
    if (root == NULL)
        return;
    if (level == 1)
        cout <<"  "<< root->key;
    else if (level > 1) {
 
        // Recursive Call
        printGivenLevel(root->left, level - 1);
        printGivenLevel(root->right, level - 1);
    }
}
 
// Function to line by line print
// level order traversal a tree
void printLevelOrder(struct node* root)
{
    int h = height(root);
    int i;
    for (i = 1; i <= h; i++) {
        printGivenLevel(root, i);
        cout <<"\n";
    }
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    printLevelOrder(root);
 
    return 0;
}
// this code is contributed by shivanisinghss2110
C
Java
Output
  50
  30  70
  20  40  60  80
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Print nodes at given Level : It prints all the nodes at a particular level of the BST.
C++
// C++ program to print nodes
// at a given level
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Print nodes at a given level
void printGivenLevel(struct node* root,
                     int level)
{
    if (root == NULL)
        return;
    if (level == 1)
        cout <<" "<< root->key;
    else if (level > 1) {
 
        // Recursive Call
        printGivenLevel(root->left, level - 1);
        printGivenLevel(root->right, level - 1);
    }
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    printGivenLevel(root, 2);
 
    return 0;
}
// this code is contributed by shivanisinghss2110
C
Java
Output
 30 70
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Print all leaf nodes: A node is a leaf node if both left and right child nodes of it are NULL.
C++
// C++ program to print all
// leaf nodes of a BST
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to print leaf nodes
// from left to right
void printLeafNodes(struct node* root)
{
    // If node is null, return
    if (!root)
        return;
 
    // If node is leaf node,
    // print its data
    if (!root->left && !root->right) {
 
        cout <<" "<< root->key;
        return;
    }
 
    // If left child exists,
    // check for leaf recursively
    if (root->left)
        printLeafNodes(root->left);
 
    // If right child exists,
    // check for leaf recursively
    if (root->right)
        printLeafNodes(root->right);
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    printLeafNodes(root);
 
    return 0;
}
 
// This code is contributed by shivanisinghss2110
C
Java
Output
 20 40 60 80
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Print all non leaf node: A node is a non leaf node if either of its left or right child nodes are not NULL.
C++
// C++ program to print all
// non leaf nodes of a BST
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to print all non-leaf
// nodes in a tree
void printNonLeafNode(struct node* root)
{
    // Base Cases
    if (root == NULL
        || (root->left == NULL
            && root->right == NULL))
        return;
 
    // If current node is non-leaf,
    if (root->left != NULL
        || root->right != NULL) {
        cout <<" "<< root->key;
    }
 
    // If root is Not NULL and its one
    // of its child is also not NULL
    printNonLeafNode(root->left);
    printNonLeafNode(root->right);
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    printNonLeafNode(root);
 
    return 0;
}
 
// This code is contributed by shivanisinghss2110
C
Java
Output
 50 30 70
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Right view of BST: Right view of a Binary Search Tree is set of nodes visible when tree is visited from Right side.
C++
// C++ program to print
// right view of a BST
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to print the right view
// of a binary tree.
void rightViewUtil(struct node* root,
                   int level,
                   int* max_level)
{
    // Base Case
    if (root == NULL)
        return;
 
    // If this is the last Node of its level
    if (*max_level < level) {
        cout <<"\t"<< root->key;
        *max_level = level;
    }
 
    // Recur for right subtree first,
    // then left subtree
    rightViewUtil(root->right, level + 1,
                  max_level);
 
    rightViewUtil(root->left, level + 1,
                  max_level);
}
 
// Wrapper over rightViewUtil()
void rightView(struct node* root)
{
    int max_level = 0;
    rightViewUtil(root, 1, &max_level);
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    rightView(root);
 
    return 0;
}
 
// This code is contributed by shivanisinghss2110
C
Java
Output
    50    70    80
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Left view of BST: Left view of a Binary Search Tree is set of nodes visible when tree is visited from Left side.
C++
// C++ program to print
// left view of a BST
#include<bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to print left view of
// binary tree
void leftViewUtil(struct node* root,
                  int level,
                  int* max_level)
{
    // Base Case
    if (root == NULL)
        return;
 
    // If this is the first node
    // of its level
    if (*max_level < level) {
        cout <<"  "<< root->key;
        *max_level = level;
    }
 
    // Recur for left and right subtrees
    leftViewUtil(root->left, level + 1,
                 max_level);
 
    leftViewUtil(root->right, level + 1,
                 max_level);
}
 
// Wrapper over leftViewUtil()
void leftView(struct node* root)
{
    int max_level = 0;
    leftViewUtil(root, 1, &max_level);
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    leftView(root);
 
    return 0;
}
 
// This code is contributed by shivanisinghss2110
C
Java
Output
  50  30  20
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Height of BST: It is recursively calculated using height of left and right subtrees of the node and assigns height to the node as max of the heights of two children plus 1.
C++
// C++ program to print
// height of a BST
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node
{
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp = (struct node*)malloc(
        sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
     
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key)
    {
        node->left = insert(node->left, key);
    }
    else if (key > node->key)
    {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Returns height of the BST
int height(struct node* node)
{
    if (node == NULL)
        return 0;
    else
    {
         
        // Compute the depth of each subtree
        int lDepth = height(node->left);
        int rDepth = height(node->right);
 
        // Use the larger one
        if (lDepth > rDepth)
            return (lDepth + 1);
        else
            return (rDepth + 1);
    }
}
 
// Driver Code
int main()
{
     
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    cout << " " << height(root);
 
    return 0;
}
 
// This code is contributed by shivanisinghss2110
C
Java
Output
 3
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Delete a Node of BST: It is used to delete a node with specific key from the BST and return the new BST.
Different scenarios for deleting the node:

Node to be deleted is the leaf node : Its simple you can just null it out.
Node to be deleted has one child : You can just replace the node with the child node.
Node to be deleted has two child :
Need to figure out what will be the replacement of the node to be deleted.
Want minimal disruption to the existing tree structure
Can table the replacement node from the deleted nodes left or right subtree.
If taking if from the left subtree, we have to take the largest value in the left subtree.
If taking if from the right subtree, we have to take the smallest value in the right subtree.
Choose one approach and stick to it. 
C++
// C++ program to delete
// a node of BST
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to do inorder traversal of BST
void inorder(struct node* root)
{
    if (root != NULL) {
        inorder(root->left);
        cout <<" "<< root->key;
        inorder(root->right);
    }
}
 
// Function that returns the node with minimum
// key value found in that tree
struct node* minValueNode(struct node* node)
{
    struct node* current = node;
 
    // Loop down to find the leftmost leaf
    while (current && current->left != NULL)
        current = current->left;
 
    return current;
}
 
// Function that deletes the key and
// returns the new root
struct node* deleteNode(struct node* root,
                        int key)
{
    // base Case
    if (root == NULL)
        return root;
 
    // If the key to be deleted is
    // smaller than the root's key,
    // then it lies in left subtree
    if (key < root->key) {
        root->left
            = deleteNode(root->left, key);
    }
 
    // If the key to be deleted is
    // greater than the root's key,
    // then it lies in right subtree
    else if (key > root->key) {
 
        root->right
            = deleteNode(root->right, key);
    }
 
    // If key is same as root's key,
    // then this is the node
    // to be deleted
    else {
 
        // Node with only one child
        // or no child
        if (root->left == NULL) {
            struct node* temp = root->right;
            free(root);
            return temp;
        }
        else if (root->right == NULL) {
            struct node* temp = root->left;
            free(root);
            return temp;
        }
 
        // Node with two children:
        // Get the inorder successor(smallest
        // in the right subtree)
        struct node* temp = minValueNode(root->right);
 
        // Copy the inorder successor's
        // content to this node
        root->key = temp->key;
 
        // Delete the inorder successor
        root->right
            = deleteNode(root->right, temp->key);
    }
    return root;
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    root = deleteNode(root, 60);
    inorder(root);
 
    return 0;
}
 
// This code is contributed by shivanisinghss2110
C
Java
Output
 20 30 40 50 70 80
Time Complexity: O(log N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Smallest Node of the BST: It is used to return the node with the smallest value in the BST.
C++
// C++ program print smallest
// element of BST
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function that returns the node with minimum
// key value found in that tree
struct node* minValueNode(struct node* node)
{
    struct node* current = node;
 
    // Loop down to find the leftmost leaf
    while (current && current->left != NULL)
        current = current->left;
 
    return current;
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    cout <<" "<< minValueNode(root)->key;
 
    return 0;
}
 
// This code is contributed by shivanisinghss2110
C
Java
Output
 20
Time Complexity: O(log N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Total number of nodes in a BST: The function returns the total count of nodes in the BST.
C++
// C++ program to print total
// count of nodes in BST
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to get the total count of
// nodes in a binary tree
int nodeCount(struct node* node)
{
    if (node == NULL)
        return 0;
 
    else
        return nodeCount(node->left)
               + nodeCount(node->right) + 1;
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // Function Call
    cout <<" "<< nodeCount(root);
 
    return 0;
}
 
// This code is contributed by shivanisinghss2110
C
Java
Output
 7
Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Delete a BST: It is used to completely delete the BST and deallocate the memory.
C++
// C++ program to delete a BST
#include <bits/stdc++.h>
using namespace std;
 
// Given Node node
struct node {
    int key;
    struct node *left, *right;
};
 
// Function to create a new BST node
struct node* newNode(int item)
{
    struct node* temp
        = (struct node*)malloc(
            sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Function to insert a new node with
// given key in BST
struct node* insert(struct node* node, int key)
{
    // If the tree is empty, return a new node
    if (node == NULL)
        return newNode(key);
 
    // Otherwise, recur down the tree
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
 
    // Return the node pointer
    return node;
}
 
// Function to do inorder traversal of BST
void inorder(struct node* root)
{
    if (root != NULL) {
        inorder(root->left);
        cout<< " "<< root->key;
        inorder(root->right);
    }
}
 
// Function to delete the BST
struct node* emptyBST(struct node* root)
{
    struct node* temp;
    if (root != NULL) {
 
        // Traverse to left subtree
        emptyBST(root->left);
 
        // Traverse to right subtree
        emptyBST(root->right);
 
        cout<<"\nReleased node:"<< root->key;
        temp = root;
 
        // Require for free memory
        free(temp);
    }
    return root;
}
 
// Driver Code
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80
   */
    struct node* root = NULL;
 
    // Creating the BST
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    cout<<"BST before deleting:\n";
    inorder(root);
 
    // Function Call
    root = emptyBST(root);
 
    return 0;
}
// This code is contributed by shivanisinghss2110
C
Java
Output: 
BST before deleting:
20 30 40 50 60 70 80 
Released node:20 
Released node:40 
Released node:30 
Released node:60 
Released node:80 
Released node:70 
Released node:50 
 

Time Complexity: O(N), where N is the number of nodes of the BST 
Auxiliary Space: O(1) 

Applications of BST:
Graph algorithms: BSTs can be used to implement graph algorithms, such as in minimum spanning tree algorithms.
Priority Queues: BSTs can be used to implement priority queues, where the element with the highest priority is at the root of the tree, and elements with lower priority are stored in the subtrees.
Self-balancing binary search tree: BSTs can be used as a self-balancing data structures such as AVL tree and Red-black tree.
Data storage and retrieval: BSTs can be used to store and retrieve data quickly, such as in databases, where searching for a specific record can be done in logarithmic time.
 
Advantages:
Fast search: Searching for a specific value in a BST has an average time complexity of O(log n), where n is the number of nodes in the tree. This is much faster than searching for an element in an array or linked list, which have a time complexity of O(n) in the worst case.
In-order traversal: BSTs can be traversed in-order, which visits the left subtree, the root, and the right subtree. This can be used to sort a dataset.
Space efficient: BSTs are space efficient as they do not store any redundant information, unlike arrays and linked lists.
Disadvantages:
Skewed trees: If a tree becomes skewed, the time complexity of search, insertion, and deletion operations will be O(n) instead of O(log n), which can make the tree inefficient.
Additional time required: Self-balancing trees require additional time to maintain balance during insertion and deletion operations.
 Efficiency: BSTs are not efficient for datasets with many duplicates as they will waste space.


Like
Next
Binary Search Tree | Set 1 (Search and Insertion)
Related Articles
1.
Data Structure Alignment : How data is arranged and accessed in Computer Memory?
2.
Bisecting K-Means Algorithm Introduction
3.
Introduction to Linear Data Structures
4.
Difference between a Data Analyst and a Data Scientist
5.
Different Sources of Data for Data Analysis
6.
Data Stream in Data Analytics
7.
Total time to visit all nodes of a binary tree
8.
Check if a Binary Tree is univalued or not
9.
The SON Algorithm and Map - Reduce
10.
Election algorithm and distributed processing
Article Contributed By :
https://media.geeksforgeeks.org/auth/avatar.png
GeeksforGeeks
Vote for difficulty
Current difficulty : Medium
Easy
Normal
Medium
Hard
Expert
Improved By :
SHUBHAMSINGH10
shivanisinghss2110
shikhasingrajput
abhijitjadhav1998
surinderdawra388
Article Tags :
Misc
Practice Tags :
Misc
Misc