Succinct Encoding of Binary Tree

Difficulty Level : Hard
Last Updated : 22 Dec, 2022
Read
Discuss
Courses
Practice
Video
A succinct encoding of Binary Tree takes close to minimum possible space. The number of structurally different binary trees on n nodes is n’th Catalan number. For large n, this is about 4n; thus we need at least about log2 4 n = 2n bits to encode it. A succinct binary tree therefore would occupy 2n+o(n) bits.

One simple representation which meets this bound is to visit the nodes of the tree in preorder, outputting “1” for an internal node and “0” for a leaf. If the tree contains data, we can simply simultaneously store it in a consecutive array in preorder.

Below is algorithm for encoding: 

function EncodeSuccinct(node n, bitstring structure, array data) {
    if n = nil then
        append 0 to structure;
    else
        append 1 to structure;
        append n.data to data;
        EncodeSuccinct(n.left, structure, data);
        EncodeSuccinct(n.right, structure, data);
}
And below is algorithm for decoding 

function DecodeSuccinct(bitstring structure, array data) {
    remove first bit of structure and put it in b
    if b = 1 then
        create a new node n
        remove first element of data and put it in n.data
        n.left = DecodeSuccinct(structure, data)
        n.right = DecodeSuccinct(structure, data)
        return n
    else
        return nil
}
Example: 

Input:   
        10
     /      \
   20       30
  /  \        \
 40   50      70 

Data Array (Contains preorder traversal)
10 20 40 50 30 70

Structure Array
1 1 1 0 0 1 0 0 1 0 1 0 0 
1 indicates data and 0 indicates NULL
Below is the implementation of above algorithms.

C++
Java
Python3
# Python program to demonstrate Succinct Tree Encoding and Decoding
 
# Node structure
class Node:
    # Utility function to create new Node
    def __init__(self , key):
        self.key = key
        self.left = None
        self.right = None
 
def EncodeSuccinct(root , struc , data):
     
    # If root is None , put 0 in structure array and return
    if root is None :
        struc.append(0)
        return
 
    # Else place 1 in structure array, key in 'data' array
    # and recur for left and right children
    struc.append(1)
    data.append(root.key)
    EncodeSuccinct(root.left , struc , data)
    EncodeSuccinct(root.right , struc ,data)
     
 
# Constructs tree from 'struc' and 'data'
def DecodeSuccinct(struc , data):
    if(len(struc) <= 0):
        return None
     
    # Remove one item from structure list
    b = struc[0]
    struc.pop(0)
     
    # If removed bit is 1
    if b == 1:
        key = data[0]
        data.pop(0)
     
        #Create a tree node with removed data
        root = Node(key)
 
        #And recur to create left and right subtrees
        root.left = DecodeSuccinct(struc , data);
        root.right = DecodeSuccinct(struc , data);
        return root
 
    return None
 
 
def preorder(root):
    if root is not None:
        print ("key: %d" %(root.key),end=" ")
             
        if root.left is not None:
            print ("| left child: %d" %(root.left.key),end=" ")
        if root.right is not None:
            print ("| right child %d" %(root.right.key),end=" ")
        print ()
        preorder(root.left)
        preorder(root.right)
 
# Driver Program
root = Node(10)
root.left = Node(20)
root.right = Node(30)
root.left.left = Node(40)
root.left.right = Node(50)
root.right.right = Node(70)        
 
print ("Given Tree")
preorder(root)
struc = []
data = []
EncodeSuccinct(root , struc , data)
 
print ("\nEncoded Tree")
print ("Structure List")
 
for i in struc:
    print (i ,end=" ")
 
print ("\nDataList")
for value in data:
    print (value,end=" ")
 
newroot = DecodeSuccinct(struc , data)
 
print ("\n\nPreorder Traversal of decoded tree")
preorder(newroot)
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
C#
Javascript
Output
Given Tree
key: 10 | left child: 20 | right child: 30
key: 20 | left child: 40 | right child: 50
key: 40
key: 50
key: 30 | right child: 70
key: 70

Encoded Tree
Structure List
1 1 1 0 0 1 0 0 1 0 1 0 0 
Data List
10 20 40 50 30 70 

Preorder traversal of decoded tree
key: 10 | left child: 20 | right child: 30
key: 20 | left child: 40 | right child: 50
key: 40
key: 50
key: 30 | right child: 70
key: 70
 Time complexity: O(n)  
Auxiliary space: O(n).

Recommended
Solve DSA problems on GfG Practice.

Solve Problems


Like
Previous
Dyck path
Next
Euler's Totient Function
Related Articles
1.
Complexity of different operations in Binary tree, Binary Search Tree and AVL tree
2.
Maximum sub-tree sum in a Binary Tree such that the sub-tree is also a BST
3.
Convert a Generic Tree(N-array Tree) to Binary Tree
4.
Check if a Binary Tree is subtree of another binary tree | Set 1
5.
Binary Tree to Binary Search Tree Conversion
6.
Check if a binary tree is subtree of another binary tree | Set 2
7.
Convert a Binary Tree to Threaded binary tree | Set 1 (Using Queue)
8.
Convert a Binary Tree to Threaded binary tree | Set 2 (Efficient)
9.
Minimum swap required to convert binary tree to binary search tree
10.
Check whether a binary tree is a full binary tree or not | Iterative Approach
Article Contributed By :
https://media.geeksforgeeks.org/auth/avatar.png
GeeksforGeeks
Vote for difficulty
Current difficulty : Hard
Easy
Normal
Medium
Hard
Expert
Improved By :
Akanksha_Rai
aashish1995
GauravRajput1
rrrtnx
sagartomar9927
amartyaghoshgfg
simmytarika5
hardikkoriintern
surajrasr7277
raj2002
Article Tags :
catalan
Tree
Practice Tags :
Tree
Report Issue